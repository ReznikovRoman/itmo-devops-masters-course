def counting_sort(array, k):
    """ Сортировка подсчётом.
    Параметры:
    - array: список целых чисел
    - k: максимальное возможное значение элемента в array (элементы от 0 до k)

    Сложность: O(n + k).
    Можно сделать устойчивой при правильной обработке.
    """
    # Подсчитываем количество каждого числа
    count = [0] * (k + 1)
    for number in array:
        count[number] += 1

    # Преобразуем counts, чтобы получить позиции
    for i in range(1, k + 1):
        count[i] += count[i - 1]

    # Заполняем результат (устойчивый вариант). Для устойчивости идём с конца массива.
    output = [0] * len(array)
    for i in reversed(range(len(array))):
        number = array[i]
        count[number] -= 1
        new_position = count[number]
        output[new_position] = number

    return output


data = [2, 5, 2, 0, 1, 4, 2]
sorted_data = counting_sort(data, k=5)
print("Counting Sort:", sorted_data)















"""
Как работает сортировка подсчётом?

Подсчёт: Создаём массив count, где count[i] — это количество элементов, равных i.
Накопление (prefix sums): Преобразуем count, чтобы count[i] хранил количество элементов, меньших или равных i.
Распределение (output array): Проходим по исходному массиву в обратном порядке,
находим корректную позицию каждого элемента в выходном массиве.
Это гарантирует устойчивость, так как равные элементы будут "вставлены" в порядке обхода.
Сложность: O(n + k), где k — диапазон возможных значений элементов
"""
