-- Допустим, у нас есть таблица servers, которая хранит данные о серверах
CREATE TABLE IF NOT EXISTS servers1 (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50),
    status BOOLEAN, -- TRUE означает, что сервер активен, FALSE — неактивен
    cpu_load INT,   -- Загрузка CPU в процентах
    ram_usage INT   -- Использование RAM в мегабайтах
);

INSERT INTO
    servers1 (name, status, cpu_load, ram_usage)
VALUES
    ('web', true, 15, 3000),
    ('server', true, 70, 60000),
    ('nginx', false, 1, 10),
    ('elk', false, 90, 10000),
    ('monitoring', true, 80, 4000);

-- Теперь нам нужно подсчитать, сколько активных и неактивных серверов в системе:
SELECT status, COUNT(*)
FROM servers1
GROUP BY status;
-- Этот запрос вернет количество серверов в каждой группе: активные и неактивные.
-- Группировка происходит по полю status.

-- Для DevOps инженера это может быть полезно при мониторинге статусов серверов,
-- чтобы понять, сколько из них в данный момент активны или отключены


-- HAVING
-- Теперь мы хотим вывести только те группы серверов, у которых средняя загрузка процессора превышает 30%:
SELECT status, AVG(cpu_load)
FROM servers1
GROUP BY status
HAVING AVG(cpu_load) > 30;

-- Этот запрос покажет статус серверов, только если средняя загрузка CPU в группе больше 30%.
-- Такой запрос может помочь DevOps инженерам найти серверы с высокими нагрузками и
-- применить к ним оптимизацию или перераспределение ресурсов.


-- WINDOW
-- Допустим, мы хотим узнать, как менялась загрузка CPU на каждом сервере с течением времени.
-- У нас есть таблица server_loads, которая хранит историю метрик для каждого сервера:
CREATE TABLE IF NOT EXISTS server_loads (
    id SERIAL PRIMARY KEY,
    server_id INT REFERENCES servers1(id),
    timestamp TIMESTAMP,
    cpu_load INT
);

INSERT INTO
    server_loads (server_id, timestamp, cpu_load)
VALUES
    (5, '2024-10-22 19:10:25-07', 30),
    (5, '2024-10-22 19:15:25-07', 40),
    (5, '2024-10-22 19:20:25-07', 45),
    (5, '2024-10-22 19:25:25-07', 40),
    (6, '2024-10-22 19:10:25-07', 60),
    (6, '2024-10-22 19:15:25-07', 80);

-- Чтобы увидеть, как загруженность CPU менялась по каждому серверу,
-- мы можем использовать оконную функцию LAG():
SELECT server_id, timestamp, cpu_load,
       LAG(cpu_load) OVER (PARTITION BY server_id ORDER BY timestamp) AS prev_cpu_load
FROM server_loads;
-- Для DevOps инженера это полезно при анализе изменений нагрузки на сервер с течением времени.
-- Например, такие запросы можно использовать для анализа трендов или выявления аномалий в производительности.

-- Использование ROW_NUMBER() для идентификации последних записей
-- Теперь рассмотрим, как с помощью оконной функции ROW_NUMBER() можно получить
-- последние записи по каждому серверу. Это может быть полезно для мониторинга самых актуальных метрик
SELECT *
FROM (
    SELECT server_id, timestamp, cpu_load,
           ROW_NUMBER() OVER (PARTITION BY server_id ORDER BY timestamp DESC) AS rn
    FROM server_loads
) AS ranked_loads
WHERE rn = 1;
-- Этот запрос вернет последнюю метрику для каждого сервера,
-- отсортировав данные по времени в порядке убывания и выбрав первую запись для каждого сервера.

-- Этот подход эффективен для получения последних метрик мониторинга,
-- таких как загрузка процессора, использование памяти и другие показатели производительности серверов.


-- Объединение GROUP BY и оконных функций
-- В некоторых случаях нужно использовать и группировку,
-- и оконные функции для более сложных аналитических задач.
-- Например, хотим:
-- 1. Для каждого сервера посчитать количество метрик за последний день.
-- 2. Одновременно получить среднюю загрузку CPU на каждый сервер с использованием оконной функции,
-- чтобы получить "скользящее" среднее по каждому серверу.
WITH server_load_agg AS (
    SELECT server_id, AVG(cpu_load) OVER (PARTITION BY server_id) AS avg_cpu_load
    FROM server_loads
    WHERE timestamp >= NOW() - INTERVAL '1 day'
)
SELECT server_id, COUNT(*) AS metric_count, AVG(avg_cpu_load) AS avg_cpu_load
FROM server_load_agg
GROUP BY server_id;

-- В данном случае CTE помогает выполнить оконную функцию отдельно,
-- а затем уже работать с результатами в основном запросе.

-- Разберем запрос:
-- 1. CTE server_load_agg:
-- Здесь вычисляется средняя загрузка CPU по каждому серверу
-- с помощью оконной функции AVG() OVER (PARTITION BY server_id).
-- Мы используем PARTITION BY, чтобы разделить строки по каждому серверу
-- (серверы идентифицируются по полю server_id), и для каждой группы вычисляется средняя загрузка CPU.
-- Результат этого подзапроса временно сохраняется как server_load_agg.
-- 2. Основной запрос:
-- Здесь мы используем результаты из CTE server_load_agg для дальнейшей агрегации.
-- COUNT(*) подсчитывает количество метрик для каждого сервера за последний день.
-- AVG(avg_cpu_load) вычисляет среднее значение загрузки CPU, уже рассчитанное на этапе CTE,
-- что позволяет легко объединить оба шага
